{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["interface Bin {\n    path_name: string,\n}\n\nexport class Tubeify {\n    private tile: number; // # of tiles in output. One tile corresponds to one bin if tiles === -1.\n    private max_bin: number; // # of bins in input.\n    private bin_length: number; // Nucleotide length of each bins.\n    private tiles_range: number[]; // e.g. [0, 5, 10, 15, 20] according to max_bin and tile.\n\n    constructor(tile: number, max_bin: number, bin_length: number) {\n        this.tile = tile;\n        this.max_bin = max_bin;\n        this.tiles_range = tile === -1 ? \n            Array.from(new Array(this.max_bin)).map((v,i) => i) : \n            Array.from(new Array(tile)).map((v,i) => Math.round(max_bin * i / tile));\n        this.bin_length = bin_length || 0;\n    }\n\n    tiled(bin: number) {\n      // Find the tile ID by binary search on tiled_range.\n    }\n\n    tubeify(bin_json: any) {\n        let reads = [];\n        let paths = {};\n        let path_starts = {};\n        /*\n        bin_json.forEach(bin => {\n            if (paths[bin.name] === undefined) {\n                paths[bin.name] = {};\n            }\n            paths[bin.name][bin.bin] = bin;\n            if (bin.prev_bin[0] === -1) {\n                path_starts[bin.name] = bin.bin;\n            }\n        });\n\n        Object.keys(paths).forEach(path_name => {\n            let path_hash = paths[path_name];\n            let current_tile = -1;\n            let sequential_id = 0;\n            let tmp = [];\n            let current_pos = path_starts[path_name];\n\n            while(path_hash[current_pos] !== undefined) {\n                let bin = path_hash[current_pos];\n                if (current_tile !== tiled(bin.bin)) {\n                    let sequence_new = [];\n                    \n                    // Output as a single bin.\n                    let firstNodeOffset = tmp[0].bin - this.tiles_range[current_tile]; \n                    if (firstNodeOffset > 0) {\n                        sequence_new.push({type: \"link\", pos: firstNodeOffset, seq: \"translocation\", query: bin.bin });\n                    }\n                    if (bin.bin - 1 !== tmp[-1].bin ) {\n                        sequence_new.push({type: \"link\", pos:(tmp.length) * this.bin_length, seq: \"translocation\", query: bin.bin });\n                    }\n\n                    reads.push({\n                        firstNodeOffset: firstNodeOffset * this.bin_length,\n                        finalNodeCoverLength: (tmp.length) * this.bin_length,\n                        sequenceQuality: 60,\n                        is_secondary: false,\n                        Sequence: tmp.map(item => item.bin),\n                        Sequence_new: sequence_new,\n                        type: \"read\",\n                        name: bin.path_name,\n                        id: sequential_id\n                   });\n\n                    sequential_id += 1;\n                    current_tile = tiled(bin.bin);\n                    tmp = [bin];\n                } else {\n                    tmp.push(bin);\n                }\n                current_pos = bin.next_bin[0];\n            }\n            // Clean up bins\n        })\n        */\n\n\n        let previous_id = -1;\n        let previous_bin = -1;\n        bin_json.forEach(bin => {\n            if (previous_bin !== bin.path_name) {\n                previous_id = 0;\n                previous_bin = bin.path_name;\n            } else { \n                previous_id += 1;\n            }\n            let sequence_new = [];\n            // console.log(bin)\n            if (bin.prev_bin[0] !== bin.bin - 1) {\n                sequence_new.push({type: \"link\", pos:0, seq: \"translocation\", query: bin.prev_bin[0] });\n            }\n            if (bin.next_bin[0] !== bin.bin + 1) {\n                sequence_new.push({type: \"link\", pos:this.bin_length, seq: \"translocation\", query: bin.next_bin[0] });\n            }\n            reads.push({\n                firstNodeOffset: 0,\n                finalNodeCoverLength: this.bin_length,\n                sequenceQuality: 60,\n                is_secondary: false,\n                Sequence: [bin.bin],\n                Sequence_new: sequence_new,\n                type: \"read\",\n                name: bin.path_name,\n                id: previous_id\n           });\n       })\n\n        let tubemap_json = {};\n        const nodes = Array.from(new Array(this.max_bin)).map((v,i) => \n            {return {name: String(i+1), sequenceLength: this.bin_length}}\n        );\n        tubemap_json[\"nodes\"] = nodes;\n        tubemap_json[\"paths\"] = [{id: 0, name: \"1\", sequence: nodes.map(node => node.name)}];\n        tubemap_json[\"reads\"] = reads;\n\n        return tubemap_json\n    }\n\n}\n"],"names":["Tubeify","constructor","tile","max_bin","bin_length","tiles_range","Array","from","this","map","v","i","Math","round","tiled","bin","tubeify","bin_json","reads","previous_id","previous_bin","forEach","path_name","sequence_new","prev_bin","push","query","next_bin","pos","finalNodeCoverLength","Sequence","name","tubemap_json","nodes","String","sequenceLength","sequence","node"],"mappings":"IAIaA,EAMTC,SAAYC,EAAcC,EAAiBC,QAClCF,KAAOA,OACPC,QAAUA,OACVE,aAAwB,IAAVH,EACfI,MAAMC,KAAK,IAAID,MAAME,KAAKL,UAAUM,aAAKC,EAAEC,UAAMA,IACjDL,MAAMC,KAAK,IAAID,MAAMJ,IAAOO,aAAKC,EAAEC,UAAMC,KAAKC,MAAMV,EAAUQ,EAAIT,UACjEE,WAAaA,GAAc,GAGpCU,YAAAA,eAAMC,KAINC,YAAAA,iBAAQC,cACAC,EAAQ,GA4DRC,GAAe,EACfC,GAAgB,EACpBH,EAASI,iBAAQN,GACTK,IAAiBL,EAAIO,aACP,EACdF,EAAeL,EAAIO,cAEJ,MAEfC,EAAe,GAEfR,EAAIS,SAAS,KAAOT,EAAIA,IAAM,KACjBU,KAAK,MAAO,WAAY,MAAQ,gBAAiBC,MAAOX,EAAIS,SAAS,KAElFT,EAAIY,SAAS,KAAOZ,EAAIA,IAAM,KACjBU,KAAK,MAAO,OAAQG,IAAIpB,EAAKJ,eAAiB,gBAAiBsB,MAAOX,EAAIY,SAAS,OAE9FF,KAAK,iBACU,EACjBI,qBAAsBrB,EAAKJ,2BACV,iBACH,EACd0B,SAAU,CAACf,EAAIA,kBACDQ,OACR,OACNQ,KAAMhB,EAAIO,aACNH,UAIRa,EAAe,GACbC,EAAQ3B,MAAMC,KAAK,IAAID,MAAME,KAAKL,UAAUM,aAAKC,EAAEC,SAC7C,CAACoB,KAAMG,OAAOvB,EAAE,GAAIwB,eAAgB3B,EAAKJ,qBAErD4B,EAAY,MAAYC,EACxBD,EAAY,MAAY,CAAC,IAAK,OAAS,IAAKI,SAAUH,EAAMxB,aAAI4B,UAAQA,EAAKN,SAC7EC,EAAY,MAAYd,EAEjBc"}