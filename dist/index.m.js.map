{"version":3,"file":"index.m.js","sources":["../src/index.ts"],"sourcesContent":["export class Tubeify {\r\n    private tile: number; // # of tiles in output. One tile corresponds to one bin if tiles === -1.\r\n    private max_bin: number; // # of bins in input.\r\n    private bin_length: number; // Nucleotide length of each bins.\r\n    tiles_range: number[]; // e.g. [0, 5, 10, 15, 20] according to max_bin and tile.\r\n\r\n    constructor(tile: number, bin_length: number, max_bin?: number) {\r\n        this.tile = tile;\r\n        this.tiles_range = tile === -1 ?\r\n            Array.from(new Array(this.max_bin)).map((v, i) => i) :\r\n            Array.from(new Array(tile)).map((v, i) => Math.round(max_bin * i / tile));\r\n        this.bin_length = bin_length || 0;\r\n        this.max_bin = Number.isNaN(max_bin) ? -1 : max_bin;\r\n    }\r\n\r\n    tiles(bin: number) {\r\n        // Find the tile ID by binary search on tiled_range.\r\n        // let flag = false; // It should be replaced with a binary search at least.\r\n        let tile_index = this.tiles_range.length;\r\n        this.tiles_range.forEach((range, i) => {\r\n            if (range <= bin) {\r\n                tile_index = i;\r\n                return\r\n            }\r\n        });\r\n        return tile_index\r\n    }\r\n\r\n\r\n    tileify(bin_json: any){\r\n        let matrix = [];\r\n\r\n        // Create reads for every contiguous segment of bins within a Path\r\n        bin_json.forEach((path) => { // For one Path\r\n            let temporary_reads = [];\r\n            let first_node_offset = 0;\r\n            let previous_bin_id = 0;\r\n\r\n            // Iterate bins and look at id\r\n            path.bins.forEach(bin => {\r\n                // For each contiguous range, make a Read\r\n                if (bin[0] === previous_bin_id + 1) {// Contiguous from the previous bin: do nothing\r\n                } else {// Not contiguous: Create a new read.\r\n                    temporary_reads.push(newRead(first_node_offset, previous_bin_id, path.id));\r\n                    first_node_offset = bin[0];\r\n                }\r\n                previous_bin_id = bin[0];\r\n            });\r\n            temporary_reads.push(newRead(first_node_offset, previous_bin_id, path.id));\r\n\r\n            // Links: inside of one read:   \r\n            // Input Example:  [ 5, 10]  meaning bins 5 and 10 are connected\r\n            path[\"links\"].forEach((link) => {\r\n                let index = binary_search(link[0], temporary_reads);\r\n                // Pos uses relative coordinates = first bin_id -  firstNodeOffset\r\n                temporary_reads[index].sequenceNew[0].mismatches.push({\r\n                    type: \"link\", pos: link[0] - temporary_reads[index].firstNodeOffset, seq: \"L\", query: link[1]\r\n                });\r\n                //make second link bidirectional\r\n                let buddy = binary_search(link[1], temporary_reads);\r\n                temporary_reads[buddy].sequenceNew[0].mismatches.push({\r\n                    type: \"link\", pos: link[1] - temporary_reads[buddy].firstNodeOffset, seq: \"L\", query: link[0]\r\n                });\r\n            });\r\n            matrix.concat(temporary_reads);\r\n        });\r\n\r\n        let tubemap_json = {};\r\n        tubemap_json[\"nodes\"] = [{\"name\": \"Layout\", \"sequenceLength\": this.max_bin}];\r\n        tubemap_json[\"tracks\"] = [{ id: 0, name: \"REF\", sequence: [\"Layout\"] }];\r\n        tubemap_json[\"reads\"] = matrix;\r\n\r\n        return tubemap_json;\r\n\r\n        function newRead(first_node_offset: number, previous_bin_id: number, path_id: number) {\r\n            // Placeholder of sequence_new.\r\n            let stub = {0: {nodeName: \"0\", mismatches: []}};\r\n\r\n            return {\r\n                firstNodeOffset: first_node_offset,\r\n                finalNodeCoverLength: previous_bin_id - first_node_offset,\r\n                mapping_quality: 60,\r\n                is_secondary: false,\r\n                sequence: [\"Layout\"],\r\n                sequenceNew: stub,\r\n                type: \"read\",\r\n                read_id: path_id,\r\n                id: path_id\r\n            };\r\n        }\r\n        function binary_search(target, sorted_data){\r\n            // d=data, t=target, s=start, e=end, m=middle\r\n            //d[i][0] is the bin_id we are sorted and searching for\r\n            const binarySearch = (d, t, s, e) => {\r\n                const m = Math.floor((s + e)/2);\r\n                if (t == d[m][0]) return d[m];\r\n                if (e - 1 === s) return d[e][0] == t ? d[e] : d[s];  //return first read, unless e is exact match\r\n                if (t > d[m][0]) return binarySearch(d,t,m,e);\r\n                if (t < d[m][0]) return binarySearch(d,t,s,m);\r\n            };\r\n            return binarySearch(sorted_data, target, 0, sorted_data.length-1)\r\n        }\r\n\r\n    }\r\n\r\n    tubeify(bin_json: any) {\r\n        let reads = [];\r\n        let paths = {};\r\n        let path_starts = {};\r\n        let max_bin_id = 0;\r\n\r\n        bin_json.forEach(bin => {\r\n            if (paths[bin.name] === undefined) {\r\n                paths[bin.name] = {};\r\n            }\r\n            paths[bin.name][bin.bin_id] = bin;\r\n            if (bin.begins[0][0] === -1) {\r\n                path_starts[bin.name] = bin.bin_id;\r\n            }\r\n            if (max_bin_id < bin.bin_id) {\r\n                max_bin_id = bin.bin_id; \r\n            }\r\n        });\r\n\r\n        if (this.max_bin === -1) {\r\n            this.max_bin = max_bin_id;\r\n        }\r\n\r\n\r\n        let previous_id = -1;\r\n        let path_unique_id = -1;\r\n        let previous_bin = -1;\r\n        bin_json.forEach(bin => {\r\n            bin.begins.forEach((begin, index) => {\r\n                // let index = 0;\r\n                if (previous_bin !== bin.path_name) {\r\n                    previous_id = 0;\r\n                    previous_bin = bin.path_name;\r\n                    path_unique_id += 1;\r\n                } else {\r\n                    previous_id += 1;\r\n                }\r\n                let sequence_new = [{\r\n                    nodeName: String(bin.bin_id),\r\n                    mismatches: []\r\n                }];\r\n                // console.log(bin)\r\n                if (bin.begins[index][0] + 1 !== bin.bin_id - 1 && bin.begins[index][0] !== -1) {\r\n                    sequence_new[0].mismatches.push({\r\n                        type: \"link\", pos: 0, seq: \"L\", query: bin.begins[index][0] + 1 // Dirty fix\r\n                    });\r\n                }\r\n                if (bin.ends[index][0] + 1 !== bin.bin_id + 1 && bin.ends[index][0] !== -1) {\r\n                    sequence_new[0].mismatches.push({\r\n                        type: \"link\", pos: this.bin_length, seq: \"L\", query: bin.ends[index][0] + 1 // Dirty fix\r\n                    });\r\n                }\r\n                reads.push({\r\n                    firstNodeOffset: 0,\r\n                    finalNodeCoverLength: this.bin_length,\r\n                    mapping_quality: 60,\r\n                    is_secondary: false,\r\n                    sequence: [String(bin.bin_id)],\r\n                    sequenceNew: sequence_new,\r\n                    type: \"read\",\r\n                    read_id: previous_id,\r\n                    name: bin.path_name, // + \":\" + String(previous_id),\r\n                    id: path_unique_id,\r\n                });\r\n            })\r\n        });\r\n\r\n        // Merging nodes:\r\n        let previous_read_id = -1;\r\n        let previous_path_unique_id = -1;\r\n        let previous_reads = [];\r\n        let new_reads = [];\r\n        reads.forEach(read => {\r\n            if ((read.id !== previous_path_unique_id || parseInt(read.sequence[0]) !== previous_read_id + 1) && previous_reads.length > 0) {\r\n                new_reads.push({\r\n                    firstNodeOffset: 0,\r\n                    finalNodeCoverLength: previous_reads.length,\r\n                    mapping_quality: 60,\r\n                    is_secondary: false,\r\n                    sequence: previous_reads.map(item => item.sequence[0]),\r\n                    sequenceNew: previous_reads.map(item => item.sequenceNew[0]),\r\n                    type: \"read\",\r\n                    name: previous_reads[0][\"name\"],\r\n                    id: previous_path_unique_id,\r\n                })\r\n                previous_path_unique_id = read.id;\r\n                previous_reads = [read];\r\n            } else if ((read.id !== previous_path_unique_id || parseInt(read.sequence[0]) !== previous_read_id + 1) ) {\r\n                previous_path_unique_id = read.id;\r\n                previous_reads = [read];\r\n            } else {\r\n                previous_reads.push(read);\r\n            }\r\n            previous_read_id = parseInt(read.sequence[0]);\r\n        })\r\n        if (previous_reads.length > 0) {\r\n            new_reads.push({\r\n                firstNodeOffset: 0,\r\n                finalNodeCoverLength: this.bin_length * previous_reads.length,\r\n                mapping_quality: 60,\r\n                is_secondary: false,\r\n                sequence: previous_reads.map(item => item.sequence[0]),\r\n                sequenceNew: previous_reads.map(item => item.sequenceNew[0]),\r\n                type: \"read\",\r\n                name: previous_reads[0].name,\r\n                id: previous_path_unique_id,\r\n            });\r\n        }\r\n        reads = new_reads;\r\n\r\n        let tubemap_json = {};\r\n        const nodes = Array.from(new Array(this.max_bin)).map((v, i) => { return { name: String(i + 1), sequenceLength: this.bin_length } }\r\n        );\r\n        tubemap_json[\"nodes\"] = nodes;\r\n        tubemap_json[\"tracks\"] = [{ id: 0, name: \"REF\", sequence: nodes.map(node => node.name) }];\r\n        tubemap_json[\"reads\"] = reads;\r\n\r\n        return tubemap_json\r\n    }\r\n\r\n}\r\n"],"names":["Tubeify","constructor","tile","bin_length","max_bin","tiles_range","Array","from","this","map","v","i","Math","round","Number","isNaN","tiles","bin","tile_index","length","forEach","range","tileify","bin_json","path","temporary_reads","first_node_offset","previous_bin_id","bins","push","newRead","id","link","index","binary_search","sequenceNew","mismatches","pos","firstNodeOffset","query","buddy","tubemap_json","sequence","path_id","finalNodeCoverLength","target","sorted_data","binarySearch","d","t","s","e","m","floor","tubeify","reads","paths","max_bin_id","undefined","name","bin_id","previous_id","path_unique_id","previous_bin","begins","begin","path_name","sequence_new","nodeName","String","ends","previous_read_id","previous_path_unique_id","previous_reads","new_reads","read","parseInt","item","nodes","sequenceLength","node"],"mappings":"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"}