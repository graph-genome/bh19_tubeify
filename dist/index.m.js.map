{"version":3,"file":"index.m.js","sources":["../src/index.ts"],"sourcesContent":["interface Bin {\r\n    path_name: string,\r\n\r\n}\r\n\r\nexport class Tubeify {\r\n    private tile: number; // # of tiles in output. One tile corresponds to one bin if tiles === -1.\r\n    private max_bin: number; // # of bins in input.\r\n    private bin_length: number; // Nucleotide length of each bins.\r\n    tiles_range: number[]; // e.g. [0, 5, 10, 15, 20] according to max_bin and tile.\r\n\r\n    constructor(tile: number, bin_length: number, max_bin?: number) {\r\n        this.tile = tile;\r\n        this.tiles_range = tile === -1 ?\r\n            Array.from(new Array(this.max_bin)).map((v, i) => i) :\r\n            Array.from(new Array(tile)).map((v, i) => Math.round(max_bin * i / tile));\r\n        this.bin_length = bin_length || 0;\r\n        this.max_bin = Number.isNaN(max_bin) ? -1 : max_bin;\r\n    }\r\n\r\n    tiles(bin: number) {\r\n        // Find the tile ID by binary search on tiled_range.\r\n        // let flag = false; // It should be replaced with a binary search at least.\r\n        let tile_index = this.tiles_range.length;\r\n        this.tiles_range.forEach((range, i) => {\r\n            if (range <= bin) {\r\n                tile_index = i;\r\n                return\r\n            }\r\n        });\r\n        return tile_index\r\n    }\r\n\r\n    tubeify(bin_json: any) {\r\n        let reads = [];\r\n        let paths = {};\r\n        let path_starts = {};\r\n        let max_bin_id = 0;\r\n\r\n        bin_json.forEach(bin => {\r\n            if (paths[bin.name] === undefined) {\r\n                paths[bin.name] = {};\r\n            }\r\n            paths[bin.name][bin.bin_id] = bin;\r\n            if (bin.begins[0][0] === -1) {\r\n                path_starts[bin.name] = bin.bin_id;\r\n            }\r\n            if (max_bin_id < bin.bin_id) {\r\n                max_bin_id = bin.bin_id; \r\n            }\r\n        });\r\n\r\n        if (this.max_bin === -1) {\r\n            this.max_bin = max_bin_id;\r\n        }\r\n        /*\r\n        Object.keys(paths).forEach(path_name => {\r\n            let path_hash = paths[path_name];\r\n            let current_tile = -1;\r\n            let sequential_id = 0;\r\n            let tmp = [];\r\n            let current_pos = path_starts[path_name];\r\n\r\n            while(current_pos !== -1) {\r\n                let bin = path_hash[current_pos];\r\n                if (current_tile !== tiles(bin.bin)) {\r\n                    let sequence_new = tmp.map(a => a.);\r\n                    \r\n                    // Output as a single bin.\r\n                    let firstNodeOffset = tmp[0].bin - this.tiles_range[current_tile]; \r\n                    if (firstNodeOffset > 0) {\r\n                        sequence_new.push({type: \"link\", pos: firstNodeOffset, seq: \"translocation\", query: bin.bin });\r\n                    }\r\n                    if (bin.bin - 1 !== tmp[-1].bin ) {\r\n                        sequence_new.push({type: \"link\", pos:(tmp.length) * this.bin_length, seq: \"translocation\", query: bin.bin });\r\n                    }\r\n\r\n                    reads.push({\r\n                        firstNodeOffset: firstNodeOffset * this.bin_length,\r\n                        finalNodeCoverLength: (tmp.length) * this.bin_length,\r\n                        mapping_quality: 60,\r\n                        is_secondary: false,\r\n                        Sequence: tmp.map(item => String(item.bin_id)),\r\n                        Sequence_new: sequence_new,\r\n                        type: \"read\",\r\n                        name: bin.path_name,\r\n                        id: sequential_id\r\n                   });\r\n\r\n                    sequential_id += 1;\r\n                    current_tile = tiles(bin.bin);\r\n\r\n                    tmp = [bin];\r\n                } else {\r\n                    tmp.push(bin);\r\n                }\r\n                bin.\r\n                current_pos = bin.next_bin[0];\r\n            }\r\n            // Clean up bins\r\n\r\n            reads.push({\r\n                firstNodeOffset: firstNodeOffset * this.bin_length,\r\n                finalNodeCoverLength: (tmp.length) * this.bin_length,\r\n                mapping_quality: 60,\r\n                is_secondary: false,\r\n                Sequence: tmp.map(item => item.bin),\r\n                Sequence_new: sequence_new,\r\n                type: \"read\",\r\n                name: bin.path_name,\r\n                id: sequential_id\r\n            });\r\n        })\r\n        */\r\n\r\n\r\n        let previous_id = -1;\r\n        let path_unique_id = -1;\r\n        let previous_bin = -1;\r\n        bin_json.forEach(bin => {\r\n            bin.begins.forEach((begin, index) => {\r\n                // let index = 0;\r\n                if (previous_bin !== bin.path_name) {\r\n                    previous_id = 0;\r\n                    previous_bin = bin.path_name;\r\n                    path_unique_id += 1;\r\n                } else {\r\n                    previous_id += 1;\r\n                }\r\n                let sequence_new = [{\r\n                    nodeName: String(bin.bin_id),\r\n                    mismatches: []\r\n                }];\r\n                // console.log(bin)\r\n                if (bin.begins[index][0] + 1 !== bin.bin_id - 1 && bin.begins[index][0] !== -1) {\r\n                    sequence_new[0].mismatches.push({\r\n                        type: \"link\", pos: 0, seq: \"L\", query: bin.begins[index][0] + 1 // Dirty fix\r\n                    });\r\n                }\r\n                if (bin.ends[index][0] + 1 !== bin.bin_id + 1 && bin.ends[index][0] !== -1) {\r\n                    sequence_new[0].mismatches.push({\r\n                        type: \"link\", pos: this.bin_length, seq: \"L\", query: bin.ends[index][0] + 1 // Dirty fix\r\n                    });\r\n                }\r\n                reads.push({\r\n                    firstNodeOffset: 0,\r\n                    finalNodeCoverLength: this.bin_length,\r\n                    mapping_quality: 60,\r\n                    is_secondary: false,\r\n                    sequence: [String(bin.bin_id)],\r\n                    sequenceNew: sequence_new,\r\n                    type: \"read\",\r\n                    read_id: previous_id,\r\n                    name: bin.path_name, // + \":\" + String(previous_id),\r\n                    id: path_unique_id,\r\n                });\r\n            })\r\n        })\r\n\r\n        // Merging nodes:\r\n        let previous_read_id = -1;\r\n        let previous_path_unique_id = -1;\r\n        let previous_reads = [];\r\n        let new_reads = []\r\n        reads.forEach(read => {\r\n            if ((read.id !== previous_path_unique_id || parseInt(read.sequence[0]) !== previous_read_id + 1) && previous_reads.length > 0) {\r\n                new_reads.push({\r\n                    firstNodeOffset: 0,\r\n                    finalNodeCoverLength: previous_reads.length,\r\n                    mapping_quality: 60,\r\n                    is_secondary: false,\r\n                    sequence: previous_reads.map(item => item.sequence[0]),\r\n                    sequenceNew: previous_reads.map(item => item.sequenceNew[0]),\r\n                    type: \"read\",\r\n                    name: previous_reads[0][\"name\"],\r\n                    id: previous_path_unique_id,\r\n                })\r\n                previous_path_unique_id = read.id;\r\n                previous_reads = [read];\r\n            } else if ((read.id !== previous_path_unique_id || parseInt(read.sequence[0]) !== previous_read_id + 1) ) {\r\n                previous_path_unique_id = read.id;\r\n                previous_reads = [read];\r\n            } else {\r\n                previous_reads.push(read);\r\n            }\r\n            previous_read_id = parseInt(read.sequence[0]);\r\n        })\r\n        if (previous_reads.length > 0) {\r\n            new_reads.push({\r\n                firstNodeOffset: 0,\r\n                finalNodeCoverLength: this.bin_length * previous_reads.length,\r\n                mapping_quality: 60,\r\n                is_secondary: false,\r\n                sequence: previous_reads.map(item => item.sequence[0]),\r\n                sequenceNew: previous_reads.map(item => item.sequenceNew[0]),\r\n                type: \"read\",\r\n                name: previous_reads[0].name,\r\n                id: previous_path_unique_id,\r\n            });\r\n        }\r\n        reads = new_reads;\r\n\r\n        let tubemap_json = {};\r\n        const nodes = Array.from(new Array(this.max_bin)).map((v, i) => { return { name: String(i + 1), sequenceLength: this.bin_length } }\r\n        );\r\n        tubemap_json[\"nodes\"] = nodes;\r\n        tubemap_json[\"tracks\"] = [{ id: 0, name: \"REF\", sequence: nodes.map(node => node.name) }];\r\n        tubemap_json[\"reads\"] = reads;\r\n\r\n        return tubemap_json\r\n    }\r\n\r\n}\r\n"],"names":["Tubeify","constructor","tile","bin_length","max_bin","tiles_range","Array","from","this","map","v","i","Math","round","Number","isNaN","tiles","bin","tile_index","length","forEach","range","tubeify","bin_json","reads","paths","max_bin_id","undefined","name","bin_id","previous_id","path_unique_id","previous_bin","begins","begin","index","path_name","sequence_new","nodeName","String","mismatches","push","query","ends","pos","finalNodeCoverLength","previous_read_id","previous_path_unique_id","previous_reads","new_reads","read","id","parseInt","sequence","item","sequenceNew","tubemap_json","nodes","sequenceLength","node"],"mappings":"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"}